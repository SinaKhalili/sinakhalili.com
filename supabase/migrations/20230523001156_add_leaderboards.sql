create table "public"."crosswordleaderboards" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "name" text default ''::text,
    "password" text
);


alter table "public"."crosswordleaderboards" enable row level security;

create table "public"."crosswordleaderboards_users" (
    "leaderboard_id" integer not null,
    "user_id" integer not null
);


alter table "public"."crosswordleaderboards_users" enable row level security;

CREATE UNIQUE INDEX crosswordleaderboard_name_key ON public.crosswordleaderboards USING btree (name);

CREATE UNIQUE INDEX crosswordleaderboard_pkey ON public.crosswordleaderboards USING btree (id);

CREATE UNIQUE INDEX crosswordleaderboards_users_pkey ON public.crosswordleaderboards_users USING btree (leaderboard_id, user_id);



alter table "public"."crosswordleaderboards" add constraint "crosswordleaderboard_pkey" PRIMARY KEY using index "crosswordleaderboard_pkey";

alter table "public"."crosswordleaderboards_users" add constraint "crosswordleaderboards_users_pkey" PRIMARY KEY using index "crosswordleaderboards_users_pkey";


alter table "public"."crosswordleaderboards" add constraint "crosswordleaderboard_name_key" UNIQUE using index "crosswordleaderboard_name_key";

alter table "public"."crosswordleaderboards_users" add constraint "crosswordleaderboards_users_leaderboard_id_fkey" FOREIGN KEY (leaderboard_id) REFERENCES crosswordleaderboards(id) not valid;

alter table "public"."crosswordleaderboards_users" validate constraint "crosswordleaderboards_users_leaderboard_id_fkey";

alter table "public"."crosswordleaderboards_users" add constraint "crosswordleaderboards_users_user_id_fkey" FOREIGN KEY (user_id) REFERENCES crosswordusers(id) not valid;

alter table "public"."crosswordleaderboards_users" validate constraint "crosswordleaderboards_users_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_stats_for_room(leaderboard_id integer)
 RETURNS json
 LANGUAGE plv8
AS $function$


  var num_affected = plv8.execute(`

-- --- BEGIN SQL

WITH ranked_solves AS (
  SELECT user_id, puzzle_id, seconds_spent_solving,
    ROW_NUMBER() OVER (PARTITION BY puzzle_id ORDER BY seconds_spent_solving ASC) AS rank
  FROM crosswordsolves
  WHERE is_solved = true
    AND user_id IN (
      SELECT user_id
      FROM crosswordleaderboards_users
      WHERE leaderboard_id = $1
    )
)
SELECT crosswordusers.id, crosswordusers.username,
  COUNT(CASE WHEN rank = 1 THEN 1 END)::INTEGER AS first_place_finishes,
  COUNT(CASE WHEN rank = 2 THEN 1 END)::INTEGER AS second_place_finishes,
  COUNT(*)::INTEGER AS total_solves_attempted
FROM ranked_solves
JOIN crosswordusers ON ranked_solves.user_id = crosswordusers.id
GROUP BY crosswordusers.id, crosswordusers.username;

-- --- END SQL 
`, leaderboard_id);


  // Convert BigInt values to integers
  num_affected.forEach(row => {
    row.id = parseInt(row.id);
    row.first_place_finishes = parseInt(row.first_place_finishes);
    row.second_place_finishes = parseInt(row.second_place_finishes);
  });

  return JSON.stringify(num_affected);


$function$
;

CREATE OR REPLACE FUNCTION public.get_leaderboards_with_count()
 RETURNS json
 LANGUAGE plv8
AS $function$


  var num_affected = plv8.execute(`

-- BEGIN SQL
SELECT cl.id, cl.name, COUNT(clu.user_id) AS user_count,
  (cl.password IS NOT NULL) AS is_password_protected
FROM crosswordleaderboards cl
JOIN crosswordleaderboards_users clu ON cl.id = clu.leaderboard_id
GROUP BY cl.id, cl.name, is_password_protected;
-- END SQL

`);

  // Convert BigInt values to integers
  num_affected.forEach(row => {
    row.id = parseInt(row.id);
    row.user_count = parseInt(row.user_count);
  });

  return JSON.stringify(num_affected);


$function$
;